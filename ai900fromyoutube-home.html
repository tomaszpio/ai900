<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI-900 Practice Test — YouTube Question Bank</title>
  <style>
  :root {
    color-scheme: light;
    --page-max-width: 74rem;
    --surface: #ffffff;
    --surface-alt: #f8f9fb;
    --border: #d0d7de;
    --accent: #004578;
    --accent-soft: rgba(0, 69, 120, 0.08);
    --glossary-width: min(320px, 26vw);
    --glossary-gap: clamp(0.75rem, 2vw, 1rem);
  }

  *,
  *::before,
  *::after {
    box-sizing: border-box;
  }

  body {
    font-family: "Segoe UI", sans-serif;
    background: var(--surface-alt);
    color: #1f1f1f;
    margin: 0;
    padding: clamp(1rem, 4vw, 2.5rem);
    line-height: 1.6;
  }

  .return-home {
    position: fixed;
    top: clamp(0.75rem, 2vw, 1.25rem);
    right: clamp(0.75rem, 3vw, 1.5rem);
    z-index: 1000;
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.45rem 0.85rem;
    background: var(--accent, #004578);
    color: #ffffff;
    border-radius: 999px;
    text-decoration: none;
    font-weight: 600;
    font-size: 0.85rem;
    border: 1px solid rgba(255, 255, 255, 0.45);
    box-shadow: 0 6px 16px rgba(0, 69, 120, 0.18);
    transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
  }

  .return-home svg {
    width: 1em;
    height: 1em;
    fill: currentColor;
  }

  .return-home:hover,
  .return-home:focus-visible {
    background: var(--accent-strong, #00345c);
    box-shadow: 0 14px 30px rgba(0, 69, 120, 0.28);
    transform: translateY(-1px);
  }

  @media (max-width: 600px) {
    .return-home {
      font-size: 0.8rem;
      padding: 0.4rem 0.75rem;
      top: 0.75rem;
      right: 0.75rem;
    }
  }

  body > * {
    width: min(100%, var(--page-max-width));
    margin: 0 auto;
  }

  .floating-instruction {
    position: sticky;
    top: clamp(0.75rem, 2vw, 1.25rem);
    z-index: 1200;
    display: flex;
    align-items: center;
    gap: 0.75rem;
    justify-content: space-between;
    flex-wrap: wrap;
    padding: 0.85rem 1.1rem;
    margin-bottom: clamp(1rem, 3vw, 1.5rem);
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(0, 69, 120, 0.2);
    border-radius: 12px;
    box-shadow: 0 10px 24px rgba(0, 0, 0, 0.12);
    backdrop-filter: blur(8px);
  }

    .floating-instruction__copy {
      flex: 1 1 320px;
    }

    .floating-instruction p {
      margin: 0;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.65rem;
    }

    .floating-instruction__count {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.4rem 0.65rem;
      background: var(--accent-soft);
      color: #004578;
      border-radius: 10px;
      font-weight: 700;
      border: 1px solid rgba(0, 69, 120, 0.25);
    }

    .floating-instruction__actions {
      flex: 0 1 320px;
      display: flex;
      align-items: center;
      gap: 0.65rem;
      justify-content: flex-end;
      flex-wrap: wrap;
    }

  @media (min-width: 1200px) {
    body {
      padding-right: calc(clamp(1rem, 4vw, 2.5rem) + var(--glossary-width) + var(--glossary-gap));
    }
  }

    a {
      color: #004578;
    }

    a:hover,
    a:focus {
      text-decoration: underline;
    }

  .page-header {
    display: grid;
    gap: clamp(1.25rem, 4vw, 1.75rem);
    margin: 0 auto clamp(2rem, 5vw, 2.75rem);
  }

    .back-link {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.95rem;
      text-decoration: none;
      color: #414141;
    }

    .back-link::before {
      content: '←';
      font-size: 1rem;
    }

  .hero {
    display: grid;
    gap: clamp(1.5rem, 4vw, 2.25rem);
    grid-template-columns: minmax(0, 1fr);
    background: linear-gradient(135deg, rgba(0, 69, 120, 0.12), rgba(16, 124, 16, 0.1));
    border: 1px solid rgba(0, 69, 120, 0.2);
    border-radius: 18px;
    padding: clamp(1.5rem, 4vw, 2.25rem);
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
  }

    .hero-copy {
      display: grid;
      gap: 1rem;
    }

    .hero-eyebrow {
      text-transform: uppercase;
      letter-spacing: 0.1em;
      font-size: 0.78rem;
      color: #004578;
      font-weight: 700;
    }

  h1 {
    color: var(--accent);
    margin-top: 0;
    margin-bottom: 0.5rem;
    font-size: clamp(1.9rem, 4.5vw, 2.5rem);
  }

  .feature-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: clamp(0.5rem, 2vw, 0.85rem);
    font-size: 0.98rem;
  }

  .feature-list li {
    display: inline-flex;
    align-items: flex-start;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.65);
    border-radius: 12px;
    padding: clamp(0.55rem, 2vw, 0.85rem) clamp(0.7rem, 2.6vw, 1.05rem);
    border: 1px solid rgba(0, 0, 0, 0.06);
  }

    .feature-list li::before {
      content: '✔';
      color: #107c10;
      font-weight: 700;
      margin-top: 0.15rem;
    }

  .category-pills {
    display: flex;
    flex-wrap: wrap;
    gap: 0.65rem;
    margin-top: 0.4rem;
  }

  .category-pill {
    --pill-color: #004578;
    --pill-accent: rgba(0, 69, 120, 0.12);
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: center;
    gap: 0.35rem 0.5rem;
    padding: 0.55rem 0.85rem;
    border-radius: 999px;
    border: 1px solid var(--pill-color);
    background: var(--pill-accent);
    color: #0f172a;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.06);
    cursor: pointer;
    transition: transform 0.15s ease, box-shadow 0.15s ease, background-color 0.15s ease;
  }

    .category-pill:hover,
    .category-pill:focus-visible {
      transform: translateY(-1px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.08);
      outline: none;
    }

    .category-pill.is-active {
      background: color-mix(in srgb, var(--pill-accent) 70%, white);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.08);
    }

  .category-pill__dot {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: var(--pill-color);
    display: inline-block;
  }

  .category-pill__label {
    font-weight: 700;
    color: #0b1221;
  }

  .category-pill__meta {
    grid-column: 2;
    font-size: 0.85rem;
    color: #334155;
  }

  .filter-hint {
    margin: 0.35rem 0 0;
    font-size: 0.95rem;
    color: #334155;
  }

    .hero-media {
      display: grid;
      gap: 0.75rem;
    }

    .video-wrapper {
      position: relative;
      padding-bottom: 56.25%;
      height: 0;
      overflow: hidden;
      border-radius: 14px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
      border: 2px solid rgba(0, 69, 120, 0.2);
      background: #000;
    }

    .video-wrapper iframe {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: 0;
    }

    .video-credit {
      font-size: 0.85rem;
      color: #3b3b3b;
    }

  p.lead {
    max-width: 60rem;
    margin: 0;
  }

  main {
    max-width: min(64rem, 100%);
    margin: 0 auto;
    display: grid;
    gap: clamp(1.25rem, 4vw, 1.75rem);
  }

  .question-list {
    display: grid;
    gap: clamp(0.85rem, 2.8vw, 1.25rem);
    max-width: min(60rem, 100%);
    margin: 0 auto;
  }

  details.question-card {
    background: var(--surface);
    border: 1px solid #d0d7de;
    border-radius: 12px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
    padding: clamp(0.75rem, 2.5vw, 1.1rem) clamp(0.9rem, 3vw, 1.3rem);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

    details.question-card[open] {
      border-color: #004578;
      box-shadow: 0 6px 12px rgba(0, 69, 120, 0.12);
    }

  summary {
    cursor: pointer;
    display: flex;
    flex-direction: column;
    gap: 0.35rem;
    font-weight: 600;
    outline: none;
  }

  summary:focus-visible {
    outline: 3px solid rgba(0, 99, 177, 0.35);
    border-radius: 6px;
  }

    .question-number {
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: #004578;
    }

    .question-meta {
      display: inline-flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.45rem;
    }

    .question-category {
      --category-color: #004578;
      --category-accent: rgba(0, 69, 120, 0.12);
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.3rem 0.6rem;
      border-radius: 10px;
      border: 1px solid color-mix(in srgb, var(--category-color) 70%, #e5e7eb);
      background: color-mix(in srgb, var(--category-accent) 60%, white);
      color: #0b1221;
      font-size: 0.9rem;
      font-weight: 600;
      line-height: 1.3;
    }

    .question-category__swatch {
      width: 12px;
      height: 12px;
      border-radius: 4px;
      background: var(--category-color);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.08);
    }

    .question-category__label {
      white-space: normal;
    }

    .question-text p {
      margin: 0;
    }

    .question-body {
      border-top: 1px solid #d0d7de;
      margin-top: 0.75rem;
      padding-top: 0.75rem;
      display: grid;
      gap: 1rem;
    }

  .answer-block {
    background: #f1f6ff;
    border-left: 4px solid #004578;
    border-radius: 10px;
    padding: clamp(0.75rem, 2.6vw, 1.1rem) clamp(0.9rem, 3vw, 1.3rem);
  }

    .answer-block .table,
    .answer-block .row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
    }

    .answer-block .col-3,
    .answer-block .col-4,
    .answer-block .col-6,
    .answer-block .col-7,
    .answer-block .col-8,
    .answer-block .col-1 {
      flex: 1 1 200px;
    }

    .answer-block .box {
      border: 1px solid #d0d7de;
      border-radius: 8px;
      padding: 0.5rem 0.75rem;
      background: #ffffff;
    }

    .answer-block .box.dashed {
      border-style: dashed;
      background: #fdf6e3;
    }

    .answer-block .box.active {
      border-color: #107c10;
      background: #ecf9ec;
    }

    .answer-block .radioBox {
      display: inline-flex;
      gap: 0.25rem;
      align-items: center;
    }

  .choice-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 0.5rem;
  }

  .question-actions {
    display: flex;
    justify-content: flex-start;
    margin-top: 0.4rem;
  }

  .reveal-button {
    display: inline-flex;
    align-items: center;
    gap: 0.35rem;
    padding: 0.45rem 0.85rem;
    background: #ffffff;
    color: #004578;
    border: 1px solid #004578;
    border-radius: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: background-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
  }

  .reveal-button:hover,
  .reveal-button:focus-visible {
    background: #004578;
    color: #ffffff;
    box-shadow: 0 8px 16px rgba(0, 69, 120, 0.18);
  }

.choice-item {
  background: #ffffff;
  border: 1px solid #d0d7de;
    border-radius: 8px;
    padding: clamp(0.55rem, 2vw, 0.85rem) clamp(0.65rem, 2.5vw, 1rem);
    display: grid;
    gap: 0.3rem;
    cursor: pointer;
    transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    position: relative;
  }

  .choice-item:hover,
  .choice-item:focus-within {
    border-color: #004578;
    box-shadow: 0 6px 12px rgba(0, 69, 120, 0.12);
  }

  .choice-list.showing-correct .choice-item[data-correct='true']::after {
    content: '';
    position: absolute;
    top: 0.65rem;
    right: 0.65rem;
    width: 14px;
    height: 14px;
    border-radius: 4px;
    background: #c62030;
    box-shadow: 0 0 0 2px rgba(198, 32, 48, 0.35);
  }

    .choice-text {
      margin: 0;
    }

    .choice-item.is-selected {
      border-color: #004578;
      background: var(--accent-soft);
      box-shadow: 0 8px 18px rgba(0, 69, 120, 0.15);
    }

    .choice-item input[type='radio'] {
      margin-right: 0.6rem;
      accent-color: #004578;
    }

    .choice-row {
      display: inline-flex;
      align-items: flex-start;
      gap: 0.6rem;
    }

  .quiz-controls {
    background: #ffffff;
    border: 1px solid #d0d7de;
    border-radius: 12px;
    padding: clamp(0.9rem, 2.8vw, 1.2rem);
    display: grid;
    gap: 0.85rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
  }

    .quiz-controls__copy {
      color: #1f1f1f;
      font-size: 0.98rem;
      margin: 0;
    }

    .quiz-controls__copy p {
      margin: 0;
    }

    .quiz-controls__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      align-items: center;
    }

    .primary-button {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.6rem 1rem;
      background: #004578;
      color: #ffffff;
      border: 1px solid #004578;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease;
    }

      .primary-button:hover,
      .primary-button:focus-visible {
        background: #00345c;
        box-shadow: 0 8px 18px rgba(0, 69, 120, 0.2);
        transform: translateY(-1px);
      }

    .score-summary {
      margin: 0;
      font-weight: 600;
      color: #004578;
    }

  .answer-explanation {
    display: grid;
    gap: 0.4rem;
    margin-top: 0.75rem;
    padding-top: 0.75rem;
    border-top: 1px dashed rgba(0, 69, 120, 0.25);
  }

    .answer-explanation-intro {
      margin: 0;
      font-size: 0.92rem;
    }

    .answer-explanation-intro strong {
      color: #004578;
    }

    .answer-explanation-detail {
      margin: 0;
      font-size: 0.92rem;
      font-style: italic;
    }

    .answer-explanation-list {
      margin: 0;
      padding-left: 1.25rem;
      font-size: 0.92rem;
    }

    .answer-explanation-sources {
      margin-top: 0.5rem;
      padding: 0.85rem 1rem;
      border-radius: 8px;
      border-left: 3px solid rgba(0, 69, 120, 0.35);
      background: rgba(0, 69, 120, 0.05);
      display: grid;
      gap: 0.65rem;
    }

      .answer-explanation-sources-title {
        margin: 0;
        font-size: 0.9rem;
        font-weight: 600;
        color: #004578;
        text-transform: uppercase;
        letter-spacing: 0.04em;
      }

      .answer-explanation-source-list {
        list-style: none;
        margin: 0;
        padding: 0;
        display: grid;
        gap: 0.65rem;
      }

        .answer-explanation-source {
          display: grid;
          gap: 0.25rem;
        }

          .answer-explanation-source a {
            font-weight: 600;
            color: #004578;
            text-decoration: none;
          }

          .answer-explanation-source a:hover,
          .answer-explanation-source a:focus {
            text-decoration: underline;
          }

          .answer-explanation-source-summary {
            margin: 0;
            font-size: 0.88rem;
            color: #2f2f2f;
          }

    .loading-state {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      color: #004578;
      font-weight: 600;
    }

    .error-state {
      color: #9a0007;
      background: #fdecea;
      border-radius: 8px;
      padding: 0.75rem 1rem;
      border: 1px solid #f5c6cb;
    }

  .glossary-panel {
    position: fixed;
    top: clamp(4.25rem, 8vw, 5.5rem);
    right: clamp(0.75rem, 3vw, 1.35rem);
    width: var(--glossary-width);
    max-height: calc(100vh - clamp(5.5rem, 10vw, 6.75rem));
    padding: clamp(0.9rem, 2.4vw, 1.15rem);
    background: #ffffff;
    border: 1px solid var(--border);
    border-radius: 14px;
    box-shadow: 0 12px 28px rgba(0, 0, 0, 0.12);
    overflow-y: auto;
    z-index: 950;
  }

    .glossary-panel h2 {
      margin: 0 0 0.6rem;
      font-size: 1rem;
      color: #004578;
      letter-spacing: 0.01em;
    }

    .glossary-panel p {
      margin: 0 0 0.6rem;
      color: #414141;
      font-size: 0.92rem;
    }

    .glossary-list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 0.65rem;
    }

      .glossary-item {
        border: 1px solid rgba(0, 69, 120, 0.14);
        border-radius: 10px;
        padding: 0.65rem 0.75rem;
        background: rgba(0, 69, 120, 0.04);
      }

        .glossary-term {
          display: block;
          font-weight: 700;
          color: #004578;
          margin-bottom: 0.2rem;
        }

        .glossary-definition {
          margin: 0;
          font-size: 0.9rem;
          line-height: 1.5;
        }

  @media (max-width: 760px) {
    .feature-list li {
      align-items: stretch;
      flex-direction: column;
    }
  }

  @media (max-width: 640px) {
    body {
      padding: clamp(1rem, 6vw, 1.5rem);
    }

    .hero {
      padding: clamp(1.25rem, 5vw, 1.6rem);
    }

    .video-wrapper {
      border-radius: 12px;
    }
  }

  @media (max-width: 1024px) {
    .glossary-panel {
      width: min(360px, 90vw);
      right: clamp(0.65rem, 3vw, 1rem);
      bottom: clamp(0.9rem, 3vw, 1.25rem);
      top: auto;
      max-height: 42vh;
    }
  }

  @media (min-width: 960px) {
    .hero {
      grid-template-columns: minmax(0, 1.1fr) minmax(0, 0.9fr);
      align-items: center;
    }
  }
  </style>
</head>
<body>
  <div class="floating-instruction" role="status" aria-live="polite">
    <div class="floating-instruction__copy">
      <p>
        <strong>Instrukcja:</strong> kliknij, aby zaznaczyć swoją odpowiedź. Możesz w dowolnym momencie policzyć wyniki dla
        wszystkich dotychczas wybranych opcji.
        <span class="floating-instruction__count">Odpowiedziane pytania: <span id="answered-count">0</span></span>
        <span class="floating-instruction__count">Wyświetlane pytania: <span id="visible-count">0</span></span>
      </p>
    </div>
    <div class="floating-instruction__actions">
      <button type="button" class="primary-button score-button">Oblicz dotychczasowy wynik</button>
      <p class="score-summary" aria-live="polite">Nie wybrano jeszcze żadnych odpowiedzi.</p>
    </div>
  </div>
  <a class="return-home" href="./index.html">
    <svg aria-hidden="true" viewBox="0 0 24 24" focusable="false">
      <path d="M12 4.248 4.5 10v10h5v-5h5v5h5V10z"></path>
    </svg>
    <span>Home</span>
  </a>
  <header class="page-header">
    <a class="back-link" href="./index.html">Back to resource index</a>
    <div class="hero">
      <div class="hero-copy">
        <span class="hero-eyebrow">Video companion</span>
        <h1>AI-900 Practice Test — YouTube Question Bank</h1>
        <p class="lead">
          This interactive practice set was generated from questions captured in the
          <code>ai900fromyoutube.html</code> export. Follow along with the companion video and expand each card to see the
          answers and explanations pulled from the mock exam.
        </p>
        <ul class="feature-list">
          <li><strong>Interactive review:</strong> Toggle each question to reveal the solution captured from the YouTube
            walkthrough.</li>
          <li><strong>Self-paced learning:</strong> Use the cards as a checklist while you pause the video and validate your
            understanding.</li>
          <li><strong>Progress check:</strong> Select answers without spoilers, then calculate your current score whenever
            you are ready.</li>
        </ul>
        <div class="category-pills" id="category-pills" aria-label="AI-900 exam categories">
          <span class="category-pill" aria-hidden="true">
            <span class="category-pill__dot"></span>
            <span class="category-pill__label">Wczytywanie zakresów egzaminu…</span>
            <span class="category-pill__meta">AI-900</span>
          </span>
        </div>
        <p class="filter-hint" id="category-filter-hint">Kliknij kategorię, aby wyświetlić tylko pytania z tego zakresu.</p>
      </div>
      <div class="hero-media">
        <div class="video-wrapper">
          <iframe src="https://www.youtube.com/embed/6LUU9_0-0xM" title="AI-900 practice test video" allowfullscreen
            loading="lazy"></iframe>
        </div>
        <p class="video-credit">Video credit: <a href="https://www.youtube.com/watch?v=6LUU9_0-0xM">AI-900 Practice Test</a>
          on YouTube.</p>
      </div>
    </div>
  </header>

  <main>
    <section class="quiz-controls" aria-label="Quiz progress">
      <div class="quiz-controls__copy">
        <p><strong>Instrukcja:</strong> kliknij, aby zaznaczyć swoją odpowiedź. Możesz w dowolnym momencie policzyć wyniki dla
          wszystkich dotychczas wybranych opcji.</p>
      </div>
      <div class="quiz-controls__actions">
        <button type="button" class="primary-button score-button">Oblicz dotychczasowy wynik</button>
        <p class="score-summary" aria-live="polite">Nie wybrano jeszcze żadnych odpowiedzi.</p>
      </div>
    </section>
    <p id="question-loading" class="loading-state" role="status" aria-live="polite">Loading questions…</p>
    <div id="question-list" class="question-list" aria-live="polite"></div>
  </main>

  <aside class="glossary-panel" aria-labelledby="glossary-title">
    <h2 id="glossary-title">AI-900 Glossary</h2>
    <p>Key Azure AI-900 terms with quick reminders you can reference while reviewing questions.</p>
    <ul class="glossary-list">
      <li class="glossary-item">
        <span class="glossary-term">Azure AI Services (Cognitive Services)</span>
        <p class="glossary-definition">Prebuilt APIs for vision, speech, language, and decision tasks without managing models or infrastructure.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure AI Vision</span>
        <p class="glossary-definition">Image and video analysis including OCR, tagging, object detection, and spatial analysis.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Document Intelligence (Form Recognizer)</span>
        <p class="glossary-definition">Extracts structured data from forms, receipts, invoices, and documents using pretrained or custom models.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure AI Speech</span>
        <p class="glossary-definition">Provides speech-to-text, text-to-speech, custom voice, and translation capabilities.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Language Service</span>
        <p class="glossary-definition">Natural language APIs for sentiment analysis, key phrases, translation, summarization, PII detection, and Q&amp;A.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure AI Search</span>
        <p class="glossary-definition">Cloud search-as-a-service with indexing, filtering, semantic ranking, and vector search for hybrid retrieval.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure OpenAI Service</span>
        <p class="glossary-definition">Enterprise access to GPT and embedding models with Azure security, content filters, and responsible AI tooling.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure Machine Learning</span>
        <p class="glossary-definition">Platform for training, deploying, and managing ML models with tools like AutoML, pipelines, and managed endpoints.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Responsible AI</span>
        <p class="glossary-definition">Practices such as fairness, transparency, privacy, security, and accountability; includes content filters and safety evaluations.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Custom Vision</span>
        <p class="glossary-definition">A no-code portal and APIs for training custom image classifiers or object detectors using your labeled images.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Anomaly Detector</span>
        <p class="glossary-definition">Detects irregularities in time-series data for monitoring scenarios like IoT telemetry or transactions.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">AI Studio &amp; Prompt Flow</span>
        <p class="glossary-definition">Workspace for building generative AI apps, grounding prompts with data, and orchestrating evaluations.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Automated ML UI</span>
        <p class="glossary-definition">No-code interface to configure regression or classification experiments, letting you train and evaluate models without writing code.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure Machine Learning Designer</span>
        <p class="glossary-definition">Drag-and-drop canvas in Azure Machine Learning for building training and inference pipelines with low-code components.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Classification Machine Learning Model</span>
        <p class="glossary-definition">Supervised model type that predicts the category or label an item belongs to based on its features.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Clustering Machine Learning Model</span>
        <p class="glossary-definition">Unsupervised model type that groups data points by similarity without predefined labels.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Regression Machine Learning Model</span>
        <p class="glossary-definition">Supervised model type that predicts numeric outcomes—such as costs, scores, or demand—using statistical relationships in the data.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Training Dataset</span>
        <p class="glossary-definition">Portion of labeled data used to fit a model so it can learn patterns that map features to outcomes.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Validation Dataset</span>
        <p class="glossary-definition">Held-out dataset for checking how well a trained model generalizes before final testing or deployment.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Responsible AI Principles</span>
        <p class="glossary-definition">Fairness, reliability and safety, privacy and security, transparency, and accountability guide the design and evaluation of AI systems.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Accountability</span>
        <p class="glossary-definition">Ensures AI systems follow organizational standards and regulations, with clear ownership for outcomes.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Fairness</span>
        <p class="glossary-definition">Requires models to avoid unjust bias toward or against groups and to flag potential areas of bias.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Reliability and Safety</span>
        <p class="glossary-definition">Focuses on consistent, safe model behavior that avoids causing harm and degrades gracefully under stress.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Privacy and Security</span>
        <p class="glossary-definition">Protects sensitive data used in AI systems through access controls, encryption, and data minimization.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Inclusiveness</span>
        <p class="glossary-definition">Encourages solutions that work for users of different backgrounds and abilities, reducing unintentional exclusion.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Transparency</span>
        <p class="glossary-definition">Calls for clear communication of a system's purpose, limitations, and results so users understand how decisions are made.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Anomaly Detection Workload</span>
        <p class="glossary-definition">Finds unusual patterns or outliers in data streams, often used for monitoring telemetry or fraud.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Azure Bot Service</span>
        <p class="glossary-definition">Builds and deploys conversational bots from a knowledge base and connects them to channels like web chat or Teams.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Channels</span>
        <p class="glossary-definition">Deployment surfaces for bots, such as web chat, Teams, or phone menus.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Chatbot</span>
        <p class="glossary-definition">An AI agent that converses with users through predefined intents, FAQs, or generative responses.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Data Ingestion</span>
        <p class="glossary-definition">Collecting and loading raw data from sources so it can be prepared for modeling.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Data Preparation</span>
        <p class="glossary-definition">Cleaning, transforming, and shaping data—including handling missing values—before training a model.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Entity Recognition</span>
        <p class="glossary-definition">Language task that extracts names, locations, organizations, quantities, or dates from text.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Feature Engineering</span>
        <p class="glossary-definition">Creating or modifying input variables to improve model performance.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Feature Selection</span>
        <p class="glossary-definition">Choosing which columns or signals to include in a model to reduce noise and overfitting.</p>
      </li>
      <li class="glossary-item">
        <span class="glossary-term">Features and Labels</span>
        <p class="glossary-definition">Features are input variables used to predict outcomes; labels are the target values a model learns to predict.</p>
      </li>
    </ul>
  </aside>

    <script>
    const DATA_URL = 'data/data.json';
    const CATEGORY_URL = 'data/ai900_categories.json';
    const responseState = new Map();
    const categoryLookup = new Map();
    const categoryRegistry = new Map();
    const questionMeta = new Map();
    let selectedCategoryId = '';

    const CATEGORY_KEYWORDS = {
      'generative-ai': [
        'openai',
        'gpt',
        'prompt',
        'grounding',
        'copilot',
        'generative',
        'llm',
        'chat completion',
        'content filter'
      ],
      nlp: [
        'language',
        'translator',
        'speech',
        'qna',
        'text analytics',
        'bot service',
        'sentiment',
        'text-to-speech',
        'speech-to-text',
        'language understanding'
      ],
      'computer-vision': [
        'image',
        'vision',
        'ocr',
        'object detection',
        'bounding box',
        'face',
        'spatial analysis',
        'analyze image',
        'semantic segmentation'
      ],
      'machine-learning': [
        'regression',
        'classification',
        'clustering',
        'model training',
        'feature',
        'label',
        'automl',
        'designer',
        'responsible ml',
        'ml lifecycle'
      ],
      'ai-workloads': [
        'responsible ai',
        'workload',
        'azure ai services',
        'anomaly',
        'knowledge mining',
        'analytics',
        'planning'
      ]
    };

    function categorizeQuestion(question) {
      const haystack = [question.question_text, question.explanation_en, question.title]
        .filter(Boolean)
        .join(' ')
        .toLowerCase();

      for (const [categoryId, keywords] of Object.entries(CATEGORY_KEYWORDS)) {
        if (keywords.some((keyword) => haystack.includes(keyword))) {
          return categoryId;
        }
      }

      return 'ai-workloads';
    }

    function updateCategoryPillsState() {
      const pills = document.querySelectorAll('#category-pills .category-pill');
      pills.forEach((pill) => {
        const pillCategory = pill.dataset.categoryId;
        const isActive = selectedCategoryId && pillCategory === selectedCategoryId;
        pill.classList.toggle('is-active', isActive);
        pill.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      });
    }

    function applyCategoryFilter() {
      const questionList = document.getElementById('question-list');
      const filterHint = document.getElementById('category-filter-hint');

      if (!questionList) return;

      const cards = questionList.querySelectorAll('.question-card');
      let visibleCount = 0;

      cards.forEach((card) => {
        const categoryId = card.dataset.categoryId || '';
        const shouldShow = !selectedCategoryId || categoryId === selectedCategoryId;
        card.style.display = shouldShow ? '' : 'none';
        if (shouldShow) {
          visibleCount += 1;
        }
      });

      updateVisibleCounter(visibleCount);

      if (filterHint) {
        if (!selectedCategoryId) {
          filterHint.textContent = 'Kliknij kategorię, aby wyświetlić tylko pytania z tego zakresu.';
        } else {
          const categoryLabel = categoryLookup.get(selectedCategoryId) || 'wybrana kategoria';
          filterHint.textContent = `Widoczna jest kategoria: ${categoryLabel} (${visibleCount} pytań). Kliknij ponownie, aby przywrócić wszystkie.`;
        }
      }

      updateCategoryPillsState();
    }

    function handleCategorySelection(categoryId) {
      if (!categoryId) return;
      selectedCategoryId = selectedCategoryId === categoryId ? '' : categoryId;
      applyCategoryFilter();
    }

    async function renderCategories() {
      const container = document.getElementById('category-pills');
      if (!container) return;

      try {
        const response = await fetch(CATEGORY_URL);
        if (!response.ok) {
          throw new Error(`Nie udało się pobrać zakresów egzaminu (status ${response.status}).`);
        }

        const payload = await response.json();
        const categories = Array.isArray(payload.categories) ? payload.categories : [];

        if (!categories.length) {
          throw new Error('Brak kategorii do wyświetlenia.');
        }

        const fragment = document.createDocumentFragment();

        categories.forEach((category) => {
          categoryLookup.set(category.id, category.label);
          categoryRegistry.set(category.id, {
            id: category.id,
            label: category.label,
            color: category.color || '#004578',
            accent: category.accent || 'rgba(0, 69, 120, 0.12)'
          });

          const pill = document.createElement('span');
          pill.className = 'category-pill';
          pill.style.setProperty('--pill-color', category.color || '#004578');
          pill.style.setProperty('--pill-accent', category.accent || 'rgba(0, 69, 120, 0.12)');
          pill.title = category.summary || category.label;
          pill.dataset.categoryId = category.id;
          pill.tabIndex = 0;

          const dot = document.createElement('span');
          dot.className = 'category-pill__dot';
          pill.appendChild(dot);

          const label = document.createElement('span');
          label.className = 'category-pill__label';
          label.textContent = category.label;
          pill.appendChild(label);

          if (category.weight) {
            const weight = document.createElement('span');
            weight.className = 'category-pill__meta';
            weight.textContent = `Waga: ${category.weight}`;
            pill.appendChild(weight);
          }

          pill.addEventListener('click', () => handleCategorySelection(category.id));
          pill.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' || event.key === ' ') {
              event.preventDefault();
              handleCategorySelection(category.id);
            }
          });

          fragment.appendChild(pill);
        });

        container.replaceChildren(fragment);
      } catch (error) {
        container.replaceChildren();
        const fallback = document.createElement('span');
        fallback.className = 'category-pill';
        fallback.textContent = error.message;
        container.appendChild(fallback);
      }
    }

    function updateAnsweredCounter() {
      const answeredCounter = document.getElementById('answered-count');
      if (answeredCounter) {
        answeredCounter.textContent = responseState.size.toString();
      }
    }

    function updateVisibleCounter(visibleCount) {
      const visibleCounter = document.getElementById('visible-count');
      if (visibleCounter) {
        visibleCounter.textContent = visibleCount.toString();
      }
    }

    function updateScoreSummary(message) {
      document.querySelectorAll('.score-summary').forEach((summary) => {
        summary.textContent = message;
      });
    }

    function resolveCategoryMeta(categoryId) {
      if (!categoryId) return null;
      const registered = categoryRegistry.get(categoryId);
      if (registered) return registered;

      const label = categoryLookup.get(categoryId);
      return label
        ? {
            id: categoryId,
            label,
            color: '#004578',
            accent: 'rgba(0, 69, 120, 0.12)'
          }
        : null;
    }

    function handleChoiceSelection(questionIndex, choiceElement) {
      const list = choiceElement.closest('.choice-list');
      if (!list) return;

      const isMultiSelect = list.dataset.multiSelect === 'true';
      const correctLabels = JSON.parse(list.dataset.correctLabels || '[]');
      const input = choiceElement.querySelector('input');

      if (!input) return;

      if (isMultiSelect) {
        input.checked = !input.checked;
        choiceElement.classList.toggle('is-selected', input.checked);
      } else {
        list.querySelectorAll('.choice-item').forEach((item) => {
          item.classList.remove('is-selected');
          const radio = item.querySelector("input[type='radio']");
          if (radio) {
            radio.checked = false;
          }
        });

        input.checked = true;
        choiceElement.classList.add('is-selected');
      }

      const selectedLabels = Array.from(list.querySelectorAll("input:checked"))
        .map((selected) => selected.dataset.choiceLabel || selected.value)
        .filter(Boolean);

      if (selectedLabels.length) {
        const hasCompleteMatch =
          selectedLabels.length === correctLabels.length &&
          selectedLabels.every((label) => correctLabels.includes(label));

        const meta = questionMeta.get(questionIndex);

        responseState.set(questionIndex, {
          isCorrect: hasCompleteMatch,
          categoryId: meta?.categoryId || ''
        });
      } else {
        responseState.delete(questionIndex);
      }

      updateAnsweredCounter();

      if (responseState.size) {
        updateScoreSummary(`Zaznaczyłeś odpowiedzi w ${responseState.size} pytaniach. Kliknij przycisk, aby obliczyć wynik.`);
      }
    }

    function handleScoreButtonClick() {
      if (!responseState.size) {
        updateScoreSummary('Nie wybrano jeszcze żadnych odpowiedzi.');
        return;
      }

      const answered = responseState.size;
      const correct = Array.from(responseState.values()).filter((entry) => entry.isCorrect).length;
      const percent = Math.round((correct / answered) * 1000) / 10;
      const incorrectEntries = Array.from(responseState.entries()).filter(([, entry]) => !entry.isCorrect);
      const incorrectCategories = Array.from(
        new Set(
          incorrectEntries
            .map(([questionIndex, entry]) => entry.categoryId || questionMeta.get(questionIndex)?.categoryId)
            .filter(Boolean)
        )
      );

      const incorrectCategoryLabels = incorrectCategories
        .map((categoryId) => categoryLookup.get(categoryId) || categoryId)
        .join(', ');

      const incorrectQuestionNumbers = incorrectEntries
        .map(([questionIndex]) => questionMeta.get(questionIndex)?.questionNumber ?? questionIndex + 1)
        .sort((a, b) => a - b)
        .join(', ');

      let summary = `Dotychczas: ${correct} / ${answered} poprawnych (${percent}%).`;

      if (incorrectEntries.length) {
        if (incorrectQuestionNumbers) {
          summary += ` Niepoprawne pytania: ${incorrectQuestionNumbers}.`;
        }

        if (incorrectCategoryLabels) {
          summary += ` Powtórz kategorie: ${incorrectCategoryLabels}.`;
        }
      }

      updateScoreSummary(summary);
    }

    const scoreButtons = document.querySelectorAll('.score-button');
    if (scoreButtons.length) {
      scoreButtons.forEach((button) => button.addEventListener('click', handleScoreButtonClick));
    }

    updateAnsweredCounter();

    function appendTextWithLineBreaks(target, text) {
      const lines = text.split('\n');
      lines.forEach((line, index) => {
        target.appendChild(document.createTextNode(line));
        if (index < lines.length - 1) {
          target.appendChild(document.createElement('br'));
        }
      });
    }

    function appendLinkifiedText(target, text) {
      const fragment = document.createDocumentFragment();
      const urlPattern = /https?:\/\/[^\s]+/g;

      let lastIndex = 0;
      for (const match of text.matchAll(urlPattern)) {
        const preceding = text.slice(lastIndex, match.index);
        appendTextWithLineBreaks(fragment, preceding);

        const anchor = document.createElement('a');
        anchor.href = match[0];
        anchor.target = '_blank';
        anchor.rel = 'noopener noreferrer';
        anchor.textContent = match[0];
        fragment.appendChild(anchor);

        lastIndex = match.index + match[0].length;
      }

      appendTextWithLineBreaks(fragment, text.slice(lastIndex));
      target.appendChild(fragment);
    }

    function buildChoiceList(question, questionIndex) {
      if (!Array.isArray(question.choices) || !question.choices.length) {
        return null;
      }

      const correctLabels = question.choices.filter((choice) => choice.is_correct).map((choice) => choice.label || '');
      const isMultiSelect = correctLabels.length > 1;

      const list = document.createElement('ul');
      list.className = 'choice-list';
      list.dataset.correctLabels = JSON.stringify(correctLabels);
      list.dataset.multiSelect = isMultiSelect ? 'true' : 'false';

      question.choices.forEach((choice, choiceIndex) => {
        const item = document.createElement('li');
        item.className = 'choice-item';
        item.dataset.correct = choice.is_correct ? 'true' : 'false';
        item.dataset.choiceId = `${questionIndex}-${choiceIndex}`;
        item.tabIndex = 0;

        const row = document.createElement('div');
        row.className = 'choice-row';

        const radio = document.createElement('input');
        radio.type = isMultiSelect ? 'checkbox' : 'radio';
        radio.name = `question-${questionIndex}`;
        radio.dataset.choiceLabel = choice.label || '';
        radio.tabIndex = -1;
        row.appendChild(radio);

        const text = document.createElement('p');
        text.className = 'choice-text';
        text.textContent = choice.raw || `${choice.label ? `${choice.label}. ` : ''}${choice.text ?? ''}`;
        row.appendChild(text);

        item.appendChild(row);

        const selectChoice = () => handleChoiceSelection(questionIndex, item);
        item.addEventListener('click', selectChoice);
        item.addEventListener('keydown', (event) => {
          if (event.key === 'Enter' || event.key === ' ') {
            event.preventDefault();
            selectChoice();
          }
        });

        list.appendChild(item);
      });

      return list;
    }

    function buildExplanation(question) {
      if (!question.explanation_en) {
        return null;
      }

      const explanation = document.createElement('div');
      explanation.className = 'answer-explanation';

      const intro = document.createElement('p');
      intro.className = 'answer-explanation-intro';
      intro.innerHTML = '<strong>Explanation:</strong> The exported answer key confirms this selection.';
      explanation.appendChild(intro);

      const detail = document.createElement('p');
      detail.className = 'answer-explanation-detail';
      appendLinkifiedText(detail, question.explanation_en);
      explanation.appendChild(detail);

      return explanation;
    }

    function buildAnswerBlock(question, questionIndex) {
      const block = document.createElement('div');
      block.className = 'answer-block';

      const choiceList = buildChoiceList(question, questionIndex);
      if (choiceList) {
        block.appendChild(choiceList);

        const actionBar = document.createElement('div');
        actionBar.className = 'question-actions';

        const submitButton = document.createElement('button');
        submitButton.type = 'button';
        submitButton.className = 'reveal-button';
        submitButton.textContent = 'Submit';
        submitButton.addEventListener('click', () => {
          choiceList.classList.add('showing-correct');
        });

        actionBar.appendChild(submitButton);
        block.appendChild(actionBar);
      } else if (question.answer_html) {
        block.innerHTML = question.answer_html;
      } else {
        block.innerHTML = '<p>No answer data was found for this question.</p>';
      }

      const explanation = buildExplanation(question);
      if (explanation) {
        block.appendChild(explanation);
      }

      return block;
    }

    function buildQuestionCard(question, index, categoryId) {
      const questionCard = document.createElement('details');
      questionCard.className = 'question-card';
      questionCard.dataset.categoryId = categoryId || '';

      const summary = document.createElement('summary');
      const number = document.createElement('span');
      number.className = 'question-number';
      number.textContent = `Question ${question.question_number ?? index + 1}`;
      summary.appendChild(number);

      const metaBar = document.createElement('div');
      metaBar.className = 'question-meta';

      const categoryMeta = resolveCategoryMeta(categoryId);
      if (categoryMeta) {
        const categoryBadge = document.createElement('span');
        categoryBadge.className = 'question-category';
        categoryBadge.style.setProperty('--category-color', categoryMeta.color);
        categoryBadge.style.setProperty('--category-accent', categoryMeta.accent);
        categoryBadge.title = `Zakres pytania: ${categoryMeta.label}`;

        const swatch = document.createElement('span');
        swatch.className = 'question-category__swatch';
        categoryBadge.appendChild(swatch);

        const label = document.createElement('span');
        label.className = 'question-category__label';
        label.textContent = categoryMeta.label;
        categoryBadge.appendChild(label);

        metaBar.appendChild(categoryBadge);
      }

      if (metaBar.childElementCount) {
        summary.appendChild(metaBar);
      }

      const questionText = document.createElement('div');
      questionText.className = 'question-text';
      questionText.innerHTML = question.question_html || (question.question_text ? `<p>${question.question_text}</p>` : '<p>No question text available.</p>');
      summary.appendChild(questionText);

      const body = document.createElement('div');
      body.className = 'question-body';
      body.appendChild(buildAnswerBlock(question, index));

      questionCard.appendChild(summary);
      questionCard.appendChild(body);
      return questionCard;
    }

    async function loadQuestions() {
      const loadingState = document.getElementById('question-loading');
      const questionList = document.getElementById('question-list');

      try {
        await categoriesReady.catch(() => {});

        const response = await fetch(DATA_URL);
        if (!response.ok) {
          throw new Error(`Failed to load practice questions (status ${response.status}).`);
        }

        const payload = await response.json();
        const questions = Array.isArray(payload.questions) ? payload.questions : [];

        if (!questions.length) {
          throw new Error('No questions were found in the source document.');
        }

        const fragment = document.createDocumentFragment();
        questions.forEach((question, index) => {
          const categoryId = categorizeQuestion(question);
          questionMeta.set(index, { categoryId, questionNumber: question.question_number ?? index + 1 });
          fragment.appendChild(buildQuestionCard(question, index, categoryId));
        });

        questionList.appendChild(fragment);
      } catch (error) {
        const errorMessage = document.createElement('p');
        errorMessage.className = 'error-state';
        errorMessage.textContent = error.message;
        questionList.appendChild(errorMessage);
      } finally {
        if (loadingState) {
          loadingState.remove();
        }
      }
    }

    const categoriesReady = renderCategories();
    loadQuestions().then(applyCategoryFilter);
  </script>

</body>
</html>
